{"version":3,"file":"index.js","sources":["../src/ErrorBoundary.ts","../src/createUseFetch.ts"],"sourcesContent":["import { Component, ReactNode } from 'react';\n\ntype Fallback = ReactNode | ((error?: Error, retry?: () => void) => ReactNode);\n\ntype Props = {\n  fallback: Fallback;\n};\n\ntype State = {\n  error: Error | null;\n};\n\nexport class ErrorBoundary extends Component<Props, State> {\n  state = { error: null } as State;\n\n  static getDerivedStateFromError(error: Error) {\n    return { error };\n  }\n\n  retry = () => { this.setState({ error: null }); };\n\n  render() {\n    const { error } = this.state;\n    const { children, fallback } = this.props;\n    if (error) {\n      if (typeof fallback === 'function') {\n        return fallback(error, this.retry);\n      }\n      return fallback;\n    }\n    return children;\n  }\n}\n","/* eslint arrow-parens: off */ // FIXME why does it complain?\n\nimport { useCallback, useEffect, useState } from 'react';\nimport { prefetch } from 'react-suspense-fetch';\n\ntype FetchFunc<Result, Input> = (input: Input) => Promise<Result>;\n\nfunction assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nexport const createUseFetch = <Result extends object, Input>(\n  fetchFunc: FetchFunc<Result, Input>,\n  initialInput: Input,\n) => {\n  let prefetched: Result | null = prefetch(fetchFunc, initialInput);\n  const useFetch = () => {\n    const [result, setResult] = useState(() => {\n      assert(prefetched !== null, 'unexpected null in useFetch');\n      return prefetched;\n    });\n    useEffect(() => {\n      prefetched = null; // hope this frees memory\n    }, []);\n    const refetch = useCallback((input: Input) => {\n      setResult(prefetch(fetchFunc, input));\n    }, []);\n    return { result, refetch };\n  };\n  return useFetch;\n};\n\nexport const createUseFetchWithoutPrefetch = <Result extends object, Input>(\n  fetchFunc: FetchFunc<Result, Input>,\n) => {\n  const useFetch = (initialInput?: Input) => {\n    const [result, setResult] = useState<Result | null>(null);\n    useEffect(() => {\n      if (initialInput !== undefined) {\n        setResult(prefetch(fetchFunc, initialInput));\n      }\n    }, [initialInput]);\n    const refetch = useCallback((input: Input) => {\n      setResult(prefetch(fetchFunc, input));\n    }, []);\n    return { result, refetch };\n  };\n  return useFetch;\n};\n"],"names":["error","_this","setState","ErrorBoundary","getDerivedStateFromError","render","this","state","props","children","fallback","retry","Component","fetchFunc","initialInput","prefetched","prefetch","useState","condition","message","Error","assert","result","setResult","useEffect","refetch","useCallback","input","undefined"],"mappings":"mGAYA,iEACU,CAAEA,MAAO,MAMjBC,QAAQ,WAAQA,EAAKC,SAAS,CAAEF,MAAO,wGAPzCG,EAGSC,yBAAP,SAAgCJ,GAC9B,MAAO,CAAEA,MAAAA,gBAKXK,OAAA,eACUL,EAAUM,KAAKC,MAAfP,QACuBM,KAAKE,MAA5BC,IAAAA,SAAUC,IAAAA,SAClB,OAAIV,EACsB,mBAAbU,EACFA,EAASV,EAAOM,KAAKK,OAEvBD,EAEFD,MAlBwBG,oCCCL,SAC5BC,EACAC,GAEA,IAAIC,EAA4BC,WAASH,EAAWC,GAcpD,OAbiB,iBACaG,YAAS,WAEnC,OAdN,SAAgBC,EAAoBC,GAClC,IAAKD,EACH,UAAUE,MAWoB,+BAA5BC,CAAsB,OAAfN,GACAA,KAFFO,OAAQC,OAUf,OANAC,aAAU,WACRT,EAAa,OACZ,IAII,CAAEO,OAAAA,EAAQG,QAHDC,eAAY,SAACC,GAC3BJ,EAAUP,WAASH,EAAWc,MAC7B,6CAMsC,SAC3Cd,GAcA,OAZiB,SAACC,SACYG,WAAwB,MAA7CK,OAAQC,OASf,OARAC,aAAU,gBACaI,IAAjBd,GACFS,EAAUP,WAASH,EAAWC,MAE/B,CAACA,IAIG,CAAEQ,OAAAA,EAAQG,QAHDC,eAAY,SAACC,GAC3BJ,EAAUP,WAASH,EAAWc,MAC7B"}